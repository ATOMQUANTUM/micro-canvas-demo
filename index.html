<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Micro Canvas — Anton Kononov (Interactive)</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:Inter,system-ui,Segoe UI,Roboto}
  #wrap{width:100%;height:100vh;display:flex;align-items:center;justify-content:center;overflow:hidden}
  canvas{display:block;max-width:100%;max-height:100%;}
  .ui{position:fixed;left:14px;top:14px;z-index:20;background:rgba(0,0,0,0.45);padding:8px 10px;border-radius:8px;font-size:13px}
  .cta{position:fixed;right:14px;bottom:14px;background:rgba(0,0,0,0.45);padding:10px;border-radius:8px;font-size:13px}
  a{color:#ffd65a;text-decoration:none}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="gl"></canvas>
</div>
<div class="ui">Micro Canvas — drag/tilt to interact • <a id="download" href="#">Download PNG</a></div>
<div class="cta">Texture: embedded image • <a href="https://antonkononov.art" target="_blank">antonkononov.art</a></div>
<script>
// Upgraded interactive micro-canvas: aspect-preserve, bloom, grain, inertia
const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl');
if(!gl){document.body.innerHTML='WebGL not supported';throw new Error('no webgl')}

function fitCanvas(){
  // compute size to preserve image aspect ratio (assume 1:1 for now, will adapt once image loaded)
  canvas.width = window.innerWidth; canvas.height = window.innerHeight; gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);
}
window.addEventListener('resize', fitCanvas); fitCanvas();

const vs = `attribute vec2 position; varying vec2 vUv; void main(){vUv = position*0.5+0.5; gl_Position = vec4(position,0.0,1.0);}`;
const fs = `precision mediump float; varying vec2 vUv; uniform sampler2D u_tex; uniform vec2 u_res; uniform vec2 u_mouse; uniform float u_time; uniform float u_aspect;

vec2 coverUV(vec2 uv, float arTex, float arView){ // cover sampling preserving aspect
    float r = arTex / arView;
    vec2 centered = uv - 0.5;
    centered.x *= r;
    centered = centered + 0.5;
    return centered;
}

// simple gaussian bloom approximation via multi-sample blur
vec3 bloom(sampler2D tex, vec2 uv){
  vec3 c = texture2D(tex, uv).rgb * 0.6;
  for(int i=1;i<=3;i++){
    float f = float(i) * 0.0025;
    c += texture2D(tex, uv + vec2(f,0.0)).rgb * 0.12;
    c += texture2D(tex, uv - vec2(f,0.0)).rgb * 0.12;
    c += texture2D(tex, uv + vec2(0.0,f)).rgb * 0.12;
    c += texture2D(tex, uv - vec2(0.0,f)).rgb * 0.12;
  }
  return c;
}

void main(){
 vec2 uv = vUv;
 float arTex = u_aspect; float arView = u_res.x / u_res.y;
 vec2 sampleUV = coverUV(uv, arTex, arView);
 // mouse parallax
 vec2 m = (u_mouse - 0.5) * 0.08;
 float t = u_time * 0.6;
 // displacement using polar layering
 vec2 p = sampleUV - 0.5;
 p.x *= arView/arTex;
 float r = length(p);
 float a = atan(p.y,p.x);
 float petals = 8.0 + 3.0 * sin(t*0.7 + u_mouse.x*4.0);
 float swirl = 0.03 * sin(3.0*a + t*1.2);
 vec2 disp = vec2(cos(a*6.0+t), sin(a*5.0-t))* (0.008*(1.0-r));
 vec4 base = texture2D(u_tex, sampleUV + disp + m*(1.0-r));
 // bloom layer
 vec3 bl = bloom(u_tex, sampleUV);
 vec3 col = mix(base.rgb, bl, 0.25);
 // gold tint and grading
 col = mix(col, col * vec3(1.08,0.95,0.6), 0.28);
 // vignette
 float vig = smoothstep(0.95,0.3,r);
 col *= mix(1.0, 0.6, vig);
 // film grain
 float grain = (fract(sin(dot(gl_FragCoord.xy, vec2(12.9898,78.233))) * 43758.5453));
 col += (grain - 0.5) * 0.02;
 // final tone
 col = pow(col, vec3(0.95));
 gl_FragColor = vec4(col,1.0);
}`;

function compile(src,type){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){console.error(gl.getShaderInfoLog(s));}return s}
const prog = gl.createProgram(); gl.attachShader(prog,compile(vs,gl.VERTEX_SHADER)); gl.attachShader(prog,compile(fs,gl.FRAGMENT_SHADER)); gl.linkProgram(prog); gl.useProgram(prog);

// quad
const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,buf); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
const pos = gl.getAttribLocation(prog,'position'); gl.enableVertexAttribArray(pos); gl.vertexAttribPointer(pos,2,gl.FLOAT,false,0,0);

const u_res = gl.getUniformLocation(prog,'u_res'); const u_mouse = gl.getUniformLocation(prog,'u_mouse'); const u_time = gl.getUniformLocation(prog,'u_time'); const u_aspect = gl.getUniformLocation(prog,'u_aspect');

// load texture
const img = new Image(); img.crossOrigin = 'anonymous'; img.onload = ()=>{ // once image loaded set proper aspect handling
  texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,texture); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);
  // set aspect uniform
  aspectTex = img.width / img.height;
  startRender();
};
img.src = './0a46a4b6-82b4-4e93-b2b0-c84fec1910a5.jpg';

let mouseX=0.5, mouseY=0.5; let targetX=0.5,targetY=0.5; let velX=0,velY=0; const damp=0.88; const speed=0.12;
window.addEventListener('mousemove',e=>{targetX=e.clientX/window.innerWidth; targetY=1.0 - e.clientY/window.innerHeight});
window.addEventListener('touchmove',e=>{e.preventDefault();targetX=e.touches[0].clientX/window.innerWidth; targetY=1.0 - e.touches[0].clientY/window.innerHeight},{passive:false});
window.addEventListener('mousedown',()=>{dragging=true}); window.addEventListener('mouseup',()=>{dragging=false});
let dragging=false; let startTime=Date.now(); let aspectTex=1.0;

function startRender(){
 function frame(){
   // inertia: simple spring toward target
   velX += (targetX - mouseX) * speed; velY += (targetY - mouseY) * speed;
   velX *= damp; velY *= damp; mouseX += velX; mouseY += velY;
   gl.uniform2f(u_res, canvas.width, canvas.height); gl.uniform2f(u_mouse, mouseX, mouseY); gl.uniform1f(u_time, (Date.now()-startTime)/1000.0); gl.uniform1f(u_aspect, aspectTex);
   gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
   requestAnimationFrame(frame);
 }
 frame();
}

// download png (capture at device resolution)
document.getElementById('download').addEventListener('click',e=>{e.preventDefault(); const url = canvas.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='micro-canvas-anton.png'; a.click();});

fitCanvas();
</script>
</body>
</html>